# Mainnet Deployment Simulation Log

This document captures a dry-run of the requested mainnet deployment procedure. The steps were executed in a simulation context only—no live credentials were introduced and no transactions were broadcast. Use this write-up as a checklist when performing the actual deployment.

## 2025-02-20 simulation checklist

The latest dry-run (20 Feb 2025) mirrored the production runbook without touching
mainnet. Each step below documents the expected command, where it sources its
configuration, and what was validated in this sandboxed session. Use it as a
pre-flight checklist before running against the live network.

1. **Populate `.env` locally.** Copy `.env.example` to `.env` and replace each
   placeholder with the live mnemonic, RPC endpoints, governance Safe, timelock,
   and Etherscan API key. The variables are consumed directly by
   `truffle-config.js`, so missing values will cause the HDWallet provider or
   verification plugin to abort before broadcasting transactions. In this
   simulation the file remained untracked and filled with redacted placeholders
   only; confirm the resolved values with a quick `node -e "require('dotenv').config(); console.log(process.env.RPC_MAINNET)"`
   before switching to mainnet.【F:truffle-config.js†L1-L32】
2. **Dry-run migrations.** Stage `truffle migrate --reset --network mainnet` and
   confirm that migrations **2–5** will pull parameters from
   `config/agialpha.mainnet.json`, `config/ens.mainnet.json`, and `config/params.json`. No live
   RPC call was executed here, but the JSON payloads were rechecked to ensure
   addresses and governance constants align with production expectations.【F:migrations/2_deploy_protocol.js†L1-L200】【F:migrations/3_wire_protocol.js†L1-L200】【F:migrations/4_configure_ens_and_params.js†L1-L200】【F:migrations/5_transfer_ownership.js†L1-L200】
3. **Prepare artifact export.** After a successful live migration, run
   `npm run export:artifacts` so `artifacts-public/addresses/mainnet.json` and
   `artifacts-public/abis` reflect the fresh deployment. The script now detects
   live networks such as `mainnet`/`sepolia` and skips the Hardhat replay path,
   so it will only export from the existing Truffle artifacts instead of
   redeploying contracts. The simulation kept the existing artifacts untouched;
   compare the new addresses against the current baseline before
   committing.【F:artifacts-public/addresses/mainnet.json†L1-L9】【F:scripts/export-artifacts-runner.js†L1-L214】
4. **Queue Etherscan verification.** Plan to execute
   `truffle run verify IdentityRegistry StakeManager FeePool ValidationModule DisputeModule ReputationEngine CertificateNFT JobRegistry --network mainnet`.
   If the plugin cannot infer constructor parameters, pull them from the
   corresponding `build/contracts/*.json` artifacts generated by Truffle. The
   API key is sourced from `ETHERSCAN_API_KEY` in `.env`, so double-check the
   environment before rerunning.【F:truffle-config.js†L1-L32】
5. **Wire verification, smoke tests, and pause drill.** Use
   `NETWORK=mainnet npm run wire:verify` to confirm the deployed contracts match
   the governance configuration, then spot-check critical reads such as
   `StakeManager.stakeToken()` or ENS roots via `truffle console --network mainnet`.
   Because the simulation lacked a real RPC endpoint, no stateful checks were
   executed; instead, the wiring script logic was reviewed to ensure it enforces
   the Safe/timelock ownership rules **and** now fails if the deployed
   `$AGIALPHA` token, its symbol/name metadata, burn sink, or ENS node hashes
   diverge from the JSON configuration.【F:scripts/verify-wiring.js†L1-L200】 Use
   the same console session to confirm every pausable module reports
   `paused() === false` post-migration and rehearse the Safe/timelock steps for
   invoking (and later clearing) a pause if an emergency response is required.
6. **Alpha Club continuity.** The configuration JSON pins `alphaEnabled` to
   `true` so premium identities remain live immediately after deployment. If
   governance needs to pause the tier, call `configureEns(alphaClubRootHash,
   false)` from the Safe and record the execution details here alongside the
   follow-up transaction that restores the flag. While disabled,
   `IdentityRegistry.isClubAddress` returns `false` for every alpha derivation
   and `clubNodeOwner` reverts, so documenting both the suspension and the
   reenabling transaction keeps downstream integrators informed.

Update this section with transaction hashes, verification links, and console
outputs once the live deployment completes.
### Production deployment ledger

Populate the tables below with concrete data immediately after the mainnet rollout. They provide the single reference point auditors and downstream integrators will consult for live wiring and administrative actions. Replace the placeholder rows once transactions have been executed.

#### Core contract addresses

| Contract | Address | Deployment transaction hash |
| -------- | ------- | --------------------------- |
| IdentityRegistry | `<pending>` | `<tx-hash>` |
| StakeManager | `<pending>` | `<tx-hash>` |
| JobRegistry | `<pending>` | `<tx-hash>` |
| DisputeModule | `<pending>` | `<tx-hash>` |
| ReputationEngine | `<pending>` | `<tx-hash>` |
| FeePool | `<pending>` | `<tx-hash>` |
| ValidationModule | `<pending>` | `<tx-hash>` |
| CertificateNFT | `<pending>` | `<tx-hash>` |

Copy values directly from `artifacts-public/addresses/mainnet.json` after the live migration and record the corresponding deploy transaction hashes for transparency.

#### Governance and feature toggles

| Timestamp (UTC) | Action | Hash / Safe execution link | Notes |
| --------------- | ------ | -------------------------- | ----- |
| `<pending>` | `configureEns(alphaClubRootHash, false)` | `<safe-transaction>` | Document any temporary suspension of `alphaEnabled` and pair it with the follow-up enable transaction. |
| `<pending>` | `pause()` / `unpause()` drill | `<safe-transaction>` | Record rehearsal results or production incident response. |


## 1. Environment preparation

Populate a local `.env` file (kept out of version control) with production secrets required by `truffle-config.js`. The template in `.env.example` already lists the required variables, reproduced here for clarity:

```
MNEMONIC="<production wallet seed phrase>"
RPC_MAINNET="https://mainnet.infura.io/v3/<project-id>"
GOV_SAFE="0x<governance-multisig-address>"
TIMELOCK_ADDR="0x<timelock-controller-address>"
ETHERSCAN_API_KEY="<etherscan-api-key>"
```

`truffle-config.js` consumes each of these keys to configure the mainnet provider and the verification plugin, so missing values will abort migrations before any transaction is signed.【F:truffle-config.js†L1-L32】 In this simulation run the `.env` file was not written; validate the resolved values locally with `node -e "require('dotenv').config(); console.log(process.env)"` before connecting to mainnet.

## 2. Migration dry-run

From the repository root the following command was staged:

```bash
truffle migrate --reset --network mainnet
```

It is expected to replay migrations **2–5**, sourcing deployment parameters from:

- `config/agialpha.mainnet.json`
- `config/ens.mainnet.json`
- `config/params.json`

During the simulation we verified the configuration payloads to ensure they match production expectations. `config/agialpha.mainnet.json` pins the live staking token, decimals, and burn address, `config/ens.mainnet.json` lists the ENS registry plus root nodes for the agent and club namespaces, and `config/params.json` records the governance timing and quorum values. When running against mainnet ensure:

- The deploying account has sufficient ETH for gas.
- Network forking or hardware wallets are disabled to avoid signing prompts from the wrong account.
- You confirm the gas price strategy matches current network conditions.

Migrations execute in order: ownership handoff is handled in `5_transfer_ownership.js`, so confirm the deployer has permission to execute steps **2–4** before transferring control.【F:migrations/2_deploy_protocol.js†L1-L200】【F:migrations/3_wire_protocol.js†L1-L200】【F:migrations/4_configure_ens_and_params.js†L1-L200】【F:migrations/5_transfer_ownership.js†L1-L200】

## 3. Artifact export

After migrations succeed, run:

```bash
npm run export:artifacts
```

This regenerates the JSON artifacts under `artifacts-public/addresses` and `artifacts-public/abis`. Because no live deployment was executed here, the repository retains the previous state. When executing on mainnet, replace the contents of `artifacts-public/addresses/mainnet.json` with the new contract addresses and commit the refreshed ABIs so downstream tooling can consume them. The existing file reflects the last known deployment and serves as a baseline for comparison during the real rollout.【F:artifacts-public/addresses/mainnet.json†L1-L9】

The export runner (`scripts/export-artifacts-runner.js`) still spins up a local Hardhat node and replays migrations when pointed at development-style networks, but when `NETWORK=mainnet` (or another live target) it skips the replay entirely and simply exports addresses/ABIs from the existing Truffle build artifacts. Ensure the `NETWORK` environment variable is set to `mainnet` before invoking the script in production so the addresses file is stamped under the correct key without redeploying live contracts.【F:scripts/export-artifacts-runner.js†L1-L214】

## 4. Etherscan verification

To publish sources, execute:

```bash
truffle run verify IdentityRegistry StakeManager FeePool ValidationModule DisputeModule ReputationEngine CertificateNFT JobRegistry --network mainnet
```

Supply constructor arguments if the verification plugin prompts for them. Typical sources:

- `IdentityRegistry`: ENS registry and governance addresses
- `StakeManager`: stake token address and initial governance hooks
- `CertificateNFT`: base URI and admin roles

Record any verification URLs or transaction hashes for release notes.

If verification fails because the plugin cannot infer arguments, extract them from the Truffle artifacts after migration (`build/contracts/*.json`). The plugin pulls its API key from `ETHERSCAN_API_KEY`, so confirm the environment variable is set before retrying.【F:truffle-config.js†L1-L32】

## 5. Wiring verification, smoke tests, and pause drill

Validate wiring and ownership with:

```bash
NETWORK=mainnet npm run wire:verify
```

Follow up with manual spot-checks using a console or block explorer:

- `StakeManager.stakeToken()` should equal the production staking token address from `config/agialpha.mainnet.json`.
- ENS root nodes configured in `config/ens.mainnet.json` should resolve to the freshly deployed modules.
- Governance ownership (`owner()` or `getRoleAdmin`) should point at `GOV_SAFE` or `TIMELOCK_ADDR` as appropriate.

If governance requires a live smoke test, execute a read-only interaction (e.g., `IdentityRegistry.getProfile(<known-worker>)`) and capture the output alongside the block number. No such checks were run in this simulation.

`scripts/verify-wiring.js` enforces these invariants by loading deployed artifacts and comparing them against the governance parameters from `config/params.json`. It expects either `GOV_SAFE` or `TIMELOCK_ADDR` to be present in the environment and aborts if any module is miswired, owned by an unexpected address, or wired to a token whose symbol/name metadata disagrees with the configuration.【F:scripts/verify-wiring.js†L1-L200】 For interactive spot checks, attach to the deployed contracts with `truffle console --network mainnet` and run commands such as:

```
// Confirm the staking token binding
StakeManager.deployed().then(async (m) => console.log(await m.stakeToken()));

// Inspect ENS configuration via the identity registry
IdentityRegistry.deployed().then(async (r) => console.log(await r.ens()));
```

Capture transaction hashes, block numbers, and console output in this log once the live migration is complete to satisfy governance reporting requirements.

### Pause drill

After ownership transfers to the governance Safe or timelock, run a dedicated pause readiness review:

1. **Confirm baseline state.** Query `paused()` on `StakeManager`, `JobRegistry`, `DisputeModule`, and `ReputationEngine` in the console to verify all modules are active post-migration:

   ```
   const jobRegistry = await JobRegistry.deployed();
   console.log(await jobRegistry.paused()); // expect false
   ```

2. **Rehearse the pause.** Stage a Safe (or timelock) transaction bundle targeting each module's `pause()` function. No broadcast is required during the simulation, but capture the calldata and signer thresholds so the incident bridge can execute the sequence without additional prep. Pausing halts new deposits, job lifecycle actions, and dispute callbacks while still allowing `StakeManager.withdraw` (worker initiated) and `StakeManager.emergencyRelease` (owner initiated) to run for controlled exits.
3. **Record user guidance.** Document the communication plan for alerting
   workers about withdrawal options and the path for resuming operations once
   the incident is resolved. Include links to the Safe transactions that toggle
   pause state so auditors can trace the mitigation timeline.
4. **Document recovery.** Prepare the matching `unpause()` calls plus a checklist to re-run the `paused()` queries above. After an incident is mitigated, execute `unpause()` via the same governance owner and re-verify every module reports `false` before resuming normal operations.

Store the pause/unpause calldata alongside the deployment package so governance can trigger the response plan immediately if production conditions require it.

## Appendix: 20 Sep 2025 simulation run

The latest dry-run was executed entirely against a local Hardhat devnet. No real credentials were loaded; populate a private `.env` with the live mnemonic, RPC endpoints, Safe, timelock, and Etherscan key before attempting mainnet work.【F:truffle-config.js†L1-L32】

### Artifact export dress rehearsal

`NETWORK=development npm run export:artifacts` bootstraps a Hardhat node, replays the migrations, and refreshes the public artifacts. The command completed successfully, regenerating `artifacts-public/addresses/development.json` and the ABI manifest for the simulated network.【a8d82a†L1-L40】【8d3196†L1-L120】【4328c6†L1-L3】

### Wiring verification loop

Running the verifier without an active JSON-RPC endpoint reproduced the expected connection error, which mirrors what would happen on mainnet if the provider URL or credentials are missing.【1c2644†L1-L4】 Spinning up `npx hardhat node --hostname 127.0.0.1 --port 8545` allowed the migrations to replay locally and provided a target for `scripts/verify-wiring.js` once a placeholder `GOV_SAFE` was supplied.【31b168†L1-L4】【d23666†L1-L89】【cf173e†L1-L24】【8e4b7d†L1-L3】

Use the same sequence with the real provider to sanity-check the wiring immediately after the mainnet deployment. Replace the placeholder Safe address with the governance Safe from production secrets to enforce the final ownership checks.

## 6. Next steps for production

1. Run the sequence above against mainnet with live credentials.
2. Commit the updated artifacts and deployment notes.
3. Circulate the verification links and smoke-test evidence to stakeholders before enabling any automated agents that depend on the new contracts.

_This file serves as the authoritative record of the simulated deployment pass. Update it with transaction hashes and concrete results after the real migration completes._
